---
layout: post
title: 'èƒ½è°±æ•°æ®å¤„ç†'
subtitle: 'å¤„ç†'
date: 2025-11-05
categories: tech
author: yucol
cover: 'https://images.unsplash.com/photo-1529322365446-6efd62aed02e?w=1600&q=900'
cover_author: 'inma santiago'
cover_author_link: 'https://unsplash.com/@inmasantiago'

tags: åœŸå£¤å¤„æ–¹å›¾ GIS æ™ºæ…§å†œä¸š èƒ½è°±
music-id: 2746702076
---


# èƒ½è°±ä¿¡æ¯

| å…ƒç´ ç³»  | ä»£è¡¨é€šé“      | ä»£è¡¨æ ¸ç´                 | ç‰¹å¾èƒ½é‡ (keV) | åœŸå£¤æ„ä¹‰  |
| ---- | --------- | ------------------- | ---------- | ----- |
| K ç³»  | ~1460 keV | K-40                | 1460       | é’¾å…ƒç´ å«é‡ |
| Th ç³» | ~2615 keV | Tl-208ï¼ˆæ¥è‡ª Th-232 ç³»ï¼‰ | 2615       | é’å…ƒç´ å«é‡ |
| U ç³»  | ~609 keV  | Bi-214ï¼ˆæ¥è‡ª U-238 ç³»ï¼‰  | 609        | é“€å…ƒç´ å«é‡ |

ç›®å‰çš„èƒ½è°±æ¢æµ‹æœ‰ä¸¤ç§å…ƒä»¶ï¼š**NaI**å’Œ**CsI**ï¼Œå…¶ä¸­ï¼š
* é€šé“æ€»æ•°ï¼š1024
* 200é€šé“ï¼š608keV Bi-214 (U-238ç³»)
* 490é€šé“ï¼š1460keV K-40 (è‡ªç„¶æ”¾å°„æ€§)
* 868é€šé“ï¼š2614keV Tl-208 (Th-232ç³»)


# æ•°æ®å¤„ç†æ–¹æ³•

## SNIPèƒŒæ™¯å‰”é™¤

```python
class SNIP:
    def __init__(self, iterations=40):
        self.iterations = iterations
        self.background_ = None
        self.net_counts_ = None

    def fit(self, counts):
        """
        å¯¹è¾“å…¥è°±æ‰§è¡Œ SNIP èƒŒæ™¯ä¼°è®¡ï¼ˆå¯¹æ•°åŸŸç‰ˆæœ¬ï¼‰
        """
        counts = np.array(counts, dtype=float)
        # ä¸ºé˜²æ­¢ log(0)ï¼ŒåŠ ä¸Šä¸€ä¸ªå¾ˆå°çš„å¸¸æ•°
        y = np.log(counts + 1)
        bg = y.copy()

        for m in range(1, self.iterations + 1):
            temp = bg.copy()
            for i in range(m, len(y) - m):
                bg[i] = min(bg[i], (temp[i - m] + temp[i + m]) / 2.0)

        # è½¬å›çº¿æ€§åŸŸ
        bg = np.exp(bg) - 1
        self.background_ = bg
        self.net_counts_ = counts - bg
        return self.background_

    def transform(self, counts):
        if self.background_ is None:
            self.fit(counts)
        return self.net_counts_

    def fit_transform(self, counts):
        self.fit(counts)
        return self.net_counts_

    def process_csv(self, input_csv, output_csv, counts_column='counts'):
        """
        æ‰¹é‡å¤„ç† CSV æ–‡ä»¶
        :param input_csv: åŸå§‹ CSV æ–‡ä»¶è·¯å¾„
        :param output_csv: è¾“å‡º CSV æ–‡ä»¶è·¯å¾„
        :param counts_column: åŒ…å«é€šé“è®¡æ•°çš„åˆ—å
        """
        df = pd.read_csv(input_csv)

        bg_list = []
        net_list = []
        net_total_counts = [] # æ·»åŠ ç”¨äºå­˜å‚¨å‡€è®¡æ•°æ€»å’Œçš„åˆ—è¡¨

        for idx, row in df.iterrows():
            # å°†å­—ç¬¦ä¸²åˆ—è¡¨è§£æä¸º Python list
            counts = ast.literal_eval(row[counts_column])
            bg = self.fit(counts)
            net = self.transform(counts)

            bg_list.append([round(float(i), 3) for i in bg])
            net_list.append([round(float(i), 3) for i in net])
            net_total_counts.append(round(float(np.sum(net)), 3))

        # æ–°å¢åˆ—
        df['background'] = bg_list
        df['net_counts'] = net_list
        df['net_total_counts'] = net_total_counts  # æ·»åŠ å‡€è®¡æ•°æ€»å’Œåˆ—
        # åˆ›å»ºæ–°çš„DataFrameï¼Œåªä¿ç•™éœ€è¦çš„å­—æ®µ
        new_df = df[['farm_id', 'collection_time', 'latitude', 'longitude','counts', 'background', 'net_counts', 'net_total_counts']]

        # ä¿å­˜
        new_df.to_csv(output_csv, index=False)
        print(f'å¤„ç†å®Œæˆï¼Œå·²ä¿å­˜åˆ° {output_csv}')

    def plot_spectrum(self, input_csv, index=0, counts_col='counts', bg_col='background', net_col='net_counts'):
        """
        ç»˜åˆ¶æŒ‡å®šç´¢å¼•çš„è°±çº¿å¯¹æ¯”å›¾ï¼ˆåŸå§‹è°±ã€èƒŒæ™¯ã€å‡€å³°è°±ï¼‰
        :param input_csv: CSV æ–‡ä»¶è·¯å¾„ï¼ˆåŒ…å« countsã€backgroundã€net_countsï¼‰
        :param index: è¦ç»˜åˆ¶çš„è¡Œå·ï¼ˆä» 0 å¼€å§‹ï¼‰
        :param counts_col: åŸå§‹è°±åˆ—å
        :param bg_col: èƒŒæ™¯è°±åˆ—å
        :param net_col: å‡€è°±åˆ—å
        """
        # è¯»å–æ•°æ®
        df = pd.read_csv(input_csv)

        # æ£€æŸ¥ç´¢å¼•æ˜¯å¦è¶…å‡ºèŒƒå›´
        if index < 0 or index >= len(df):
            raise IndexError(f"ç´¢å¼• {index} è¶…å‡ºèŒƒå›´ï¼ˆå…±æœ‰ {len(df)} æ¡æ•°æ®ï¼‰")

        # è§£æä¸º Python åˆ—è¡¨
        counts = np.array(ast.literal_eval(df.loc[index, counts_col]), dtype=float)
        background = np.array(ast.literal_eval(df.loc[index, bg_col]), dtype=float)
        net = np.array(ast.literal_eval(df.loc[index, net_col]), dtype=float)

        # ç»˜å›¾
        plt.figure(figsize=(10, 6))
        plt.plot(counts, label='åŸå§‹è°±', color='black', linewidth=1)
        plt.plot(background, label='èƒŒæ™¯è°±', color='orange', linewidth=2)
        plt.plot(net, label='å‡€å³°è°±', color='red', linewidth=1.2)

        plt.xlabel('é€šé“å·')
        plt.ylabel('è®¡æ•°')
        plt.title(f'SNIP è°±çº¿å¯¹æ¯”å›¾ï¼ˆç¬¬ {index+1} æ¡æ•°æ®ï¼‰')
        plt.legend()
        plt.grid(alpha=0.3)
        plt.show()
```

è°ƒç”¨æ–¹æ³•ï¼ˆé»˜è®¤è¿­ä»£40æ¬¡ï¼‰ï¼š
```python
# SNIPåˆå§‹åŒ–
snip = SNIP(iterations=40)
snip.process_csv('../file/point_area_a.csv', '../file/snip_processed_area_a.csv', counts_column='counts')
snip.process_csv('../file/point_area_b.csv', '../file/snip_processed_area_b.csv', counts_column='counts')

snip.plot_spectrum('../file/snip_processed_area_a.csv', index=99)  # ç»˜åˆ¶ç¬¬100æ¡æ•°æ®
```
![image.png](https://img10.360buyimg.com/ddimg/jfs/t1/358857/36/3421/22607/690af6ecF11f4a31b/c69fa9e95096a4f5.jpg)

## çª—å£æ±‚å’Œ

```python
class SpectrumPeak:
    """
    æ ¹æ®æŒ‡å®šé€šé“å’Œçª—å£èŒƒå›´è®¡ç®—èƒ½è°±å³°å¼ºåº¦ï¼ˆçª—å£æ±‚å’Œï¼‰ï¼Œæ”¯æŒæ‰¹é‡å¤šé€šé“å¤„ç†
    """
    def __init__(self, counts_column='counts'):
        self.counts_column = counts_column  # CSV ä¸­çš„è®¡æ•°åˆ—å

    def compute_peak(self, counts, channel, window):
        """
        è®¡ç®—æŒ‡å®šé€šé“é™„è¿‘çª—å£çš„è®¡æ•°å’Œ
        :param counts: æ ·æœ¬çš„è®¡æ•°åˆ—è¡¨
        :param channel: ä¸­å¿ƒé€šé“
        :param window: çª—å£èŒƒå›´ï¼ˆæ­£è´ŸèŒƒå›´ï¼‰
        :return: çª—å£å†…è®¡æ•°å’Œ
        """
        start = max(0, channel - window)
        end = min(len(counts), channel + window + 1)  # python åˆ‡ç‰‡æ˜¯å·¦é—­å³å¼€
        return sum(counts[start:end])

    def process_csv(self, input_csv, output_csv, peaks):
        """
        å¤„ç† CSV æ–‡ä»¶ï¼Œè®¡ç®—å³°å¼ºåº¦ï¼Œå¹¶ä¿å­˜æ–° CSV
        :param input_csv: è¾“å…¥ CSV è·¯å¾„
        :param output_csv: è¾“å‡º CSV è·¯å¾„
        :param peaks: dict, {åˆ—å: (ä¸­å¿ƒé€šé“, çª—å£èŒƒå›´)}
                      ä¾‹å¦‚: {'K40_peak': (490, 5), 'U238_peak': (600, 7)}
        """
        df = pd.read_csv(input_csv)

        # å…ˆæŠŠåŸ counts åˆ—è§£ææˆåˆ—è¡¨ï¼Œæ–¹ä¾¿é‡å¤ä½¿ç”¨
        counts_list = df[self.counts_column].apply(ast.literal_eval)

        for peak_name, (channel, window) in peaks.items():
            df[peak_name] = counts_list.apply(lambda x: self.compute_peak(x, channel, window))

        df.to_csv(output_csv, index=False)
        print(f'å¤„ç†å®Œæˆï¼Œå·²ä¿å­˜åˆ° {output_csv}')
```

è°ƒç”¨æ–¹æ³•ï¼š
```python
# è·å–æŒ‡å®šé€šé“çš„çª—å£æ±‚å’Œ
sp = SpectrumPeak(counts_column='net_counts')

# å®šä¹‰è¦è®¡ç®—çš„å³°ï¼Œé”®æ˜¯è¾“å‡ºåˆ—åï¼Œå€¼æ˜¯ (ä¸­å¿ƒé€šé“, çª—å£)
peaks_to_calc = {
    'Bi214_peak': (200, 10),
    'K40_peak': (490, 10),
    'Tl208_peak': (868, 10)
}

sp.process_csv(
    input_csv='../file/snip_processed_area_a.csv',
    output_csv='../file/data_peaks_area_a.csv',
    peaks=peaks_to_calc
)
```

## ä¸»æˆåˆ†åˆ†æ

```PYTHON
class SpectrumPCA:
    """
    å…‰è°±ä¸»æˆåˆ†åˆ†æï¼ˆPCAï¼‰å°è£…ç±»
    æ”¯æŒ CSV æ–‡ä»¶æ‰¹é‡å¤„ç†ã€è‡ªåŠ¨ä¿å­˜ä¸»æˆåˆ†ç»“æœ
    """

    def __init__(self, n_components=3):
        """
        åˆå§‹åŒ– PCA æ¨¡å‹
        :param n_components: ä¸»æˆåˆ†æ•°é‡ï¼ˆé»˜è®¤ 3ï¼‰
        """
        self.n_components = n_components
        self.pca_model = PCA(n_components=n_components)
        self.components_ = None
        self.explained_variance_ratio_ = None
        self.pca_scores_ = None

    def _parse_counts(self, counts_str):
        """
        å°†å­—ç¬¦ä¸² "[1, 2, 3]" è½¬æ¢ä¸º numpy æ•°ç»„
        """
        if isinstance(counts_str, str):
            return np.array(ast.literal_eval(counts_str), dtype=float)
        elif isinstance(counts_str, (list, np.ndarray)):
            return np.array(counts_str, dtype=float)
        else:
            raise ValueError("counts åˆ—æ ¼å¼é”™è¯¯ï¼Œåº”ä¸ºå­—ç¬¦ä¸²æˆ–åˆ—è¡¨")

    def fit_transform_csv(self, input_csv, output_csv=None, counts_column='counts'):
        """
        ä» CSV æ–‡ä»¶è¯»å–èƒ½è°±æ•°æ®ï¼Œæ‰§è¡Œ PCA å¹¶ä¿å­˜ç»“æœ
        :param input_csv: è¾“å…¥ CSV æ–‡ä»¶è·¯å¾„
        :param output_csv: è¾“å‡º CSV æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼‰
        :param counts_column: å…‰è°±åˆ—åï¼ˆé»˜è®¤ 'counts'ï¼‰
        :return: åŒ…å« PCA ç»“æœçš„ DataFrame
        """
        # === 1. è¯»å– CSV ===
        df = pd.read_csv(input_csv)
        print(f"âœ… æˆåŠŸè¯»å– {len(df)} æ¡æ ·æœ¬")

        # === 2. è½¬æ¢ counts åˆ—ä¸ºçŸ©é˜µ ===
        spectra = np.array([self._parse_counts(c) for c in df[counts_column]])
        print(f"æ¯æ¡å…‰è°±é€šé“æ•°: {spectra.shape[1]}")

        # === 3. æ‰§è¡Œ PCA ===
        self.pca_scores_ = self.pca_model.fit_transform(spectra)
        self.components_ = self.pca_model.components_
        self.explained_variance_ratio_ = self.pca_model.explained_variance_ratio_

        # === 4. å°†ä¸»æˆåˆ†ç»“æœæ·»åŠ åˆ° df ===
        for i in range(self.n_components):
            df[f'PC{i+1}'] = self.pca_scores_[:, i]

        # === 5. å¯é€‰ä¿å­˜ç»“æœ ===
        if output_csv:
            base, ext = os.path.splitext(output_csv)
            result_csv = f"{base}_pca.csv"
            variance_csv = f"{base}_variance.csv"

            # ä¿å­˜ä¸»æˆåˆ†ç»“æœ
            df.to_csv(result_csv, index=False)

            # ä¿å­˜æ–¹å·®è´¡çŒ®ç‡ä¿¡æ¯
            var_df = pd.DataFrame({
                'PC': [f'PC{i+1}' for i in range(self.n_components)],
                'Explained_Variance_Ratio': self.explained_variance_ratio_
            })
            var_df.to_csv(variance_csv, index=False)

            print(f"ğŸ“‚ PCAç»“æœå·²ä¿å­˜è‡³: {result_csv}")
            print(f"ğŸ“Š æ–¹å·®è´¡çŒ®ç‡å·²ä¿å­˜è‡³: {variance_csv}")

        return df

    # ==================== æ–¹å·®è´¡çŒ®ç‡æŸ±çŠ¶å›¾ ====================
    def plot_variance_ratio(self):
        if self.explained_variance_ratio_ is None:
            raise ValueError("è¯·å…ˆè¿è¡Œ fit_transform_csv()")
        plt.figure(figsize=(6, 4))
        plt.bar(range(1, len(self.explained_variance_ratio_) + 1),
                self.explained_variance_ratio_ * 100, color='skyblue')
        plt.xlabel("ä¸»æˆåˆ†")
        plt.ylabel("æ–¹å·®è´¡çŒ®ç‡ (%)")
        plt.title("PCA æ–¹å·®è´¡çŒ®ç‡")
        plt.grid(True, alpha=0.3)
        plt.show()

    # ==================== PCA æ•£ç‚¹å›¾ ====================
    def plot_scatter(self, df, pc_x=1, pc_y=2):
        pc_x_col = f'PC{pc_x}'
        pc_y_col = f'PC{pc_y}'
        if pc_x_col not in df.columns or pc_y_col not in df.columns:
            raise ValueError("DataFrame ä¸­ç¼ºå°‘æŒ‡å®šçš„ PCA åˆ—ï¼Œè¯·å…ˆè¿è¡Œ fit_transform_csv()")
        plt.figure(figsize=(6, 6))
        plt.scatter(df[pc_x_col], df[pc_y_col], alpha=0.7, edgecolor='k')
        plt.xlabel(pc_x_col)
        plt.ylabel(pc_y_col)
        plt.title(f'PCA æ•£ç‚¹å›¾ ({pc_x_col} vs {pc_y_col})')
        plt.grid(True, alpha=0.3)
        plt.show()

    # ==================== ç©ºé—´å¯è§†åŒ– ====================
    def plot_spatial_pca(self, df, pc=1, lat_col='latitude', lon_col='longitude',
                         method='scatter', grid_res=100):
        """
        ç»˜åˆ¶ PCA ç©ºé—´åˆ†å¸ƒå›¾
        :param df: åŒ…å«ç»çº¬åº¦å’Œ PCA åˆ—çš„ DataFrame
        :param pc: PCA ç¼–å·ï¼ˆ1,2,3,...ï¼‰
        :param lat_col: çº¬åº¦åˆ—å
        :param lon_col: ç»åº¦åˆ—å
        :param method: 'scatter' æˆ– 'heatmap'
        :param grid_res: çƒ­åŠ›å›¾æ’å€¼ç½‘æ ¼åˆ†è¾¨ç‡
        """
        pc_col = f'PC{pc}'
        if pc_col not in df.columns:
            raise ValueError(f"{pc_col} åˆ—ä¸å­˜åœ¨ï¼Œè¯·å…ˆè¿è¡Œ PCA")

        lats = df[lat_col].values
        lons = df[lon_col].values
        values = df[pc_col].values

        if method == 'scatter':
            plt.figure(figsize=(8, 6))
            sc = plt.scatter(lons, lats, c=values, cmap='viridis', s=50, edgecolor='k')
            plt.colorbar(sc, label=f'{pc_col} å€¼')
            plt.xlabel('Longitude')
            plt.ylabel('Latitude')
            plt.title(f'{pc_col} ç©ºé—´æ•£ç‚¹å›¾')
            plt.grid(True, alpha=0.3)
            plt.show()

        elif method == 'heatmap':
            # åˆ›å»ºç½‘æ ¼
            lon_grid = np.linspace(lons.min(), lons.max(), grid_res)
            lat_grid = np.linspace(lats.min(), lats.max(), grid_res)
            lon_mesh, lat_mesh = np.meshgrid(lon_grid, lat_grid)

            # æ’å€¼
            grid_values = griddata((lons, lats), values, (lon_mesh, lat_mesh), method='cubic')

            # ç»˜åˆ¶çƒ­åŠ›å›¾
            plt.figure(figsize=(8, 6))
            hm = plt.imshow(grid_values, origin='lower',
                            extent=(lons.min(), lons.max(), lats.min(), lats.max()),
                            cmap='viridis', aspect='auto')
            plt.colorbar(hm, label=f'{pc_col} å€¼')
            plt.scatter(lons, lats, c='white', s=10, alpha=0.8)  # åŸå§‹ç‚¹ä½ç½®
            plt.xlabel('Longitude')
            plt.ylabel('Latitude')
            plt.title(f'{pc_col} ç©ºé—´çƒ­åŠ›å›¾')
            plt.show()
        else:
            raise ValueError("method å‚æ•°åªæ”¯æŒ 'scatter' æˆ– 'heatmap'")
```

è°ƒç”¨æ–¹æ³•ï¼š
```PYTHON
# PCAåˆå§‹åŒ–
pca = SpectrumPCA(n_components=3)

# å¯¹ CSV æ•°æ®è¿›è¡Œ PCA å¹¶ä¿å­˜ç»“æœ
df_area_a = pca.fit_transform_csv(input_csv="../file/snip_processed_area_a.csv", output_csv="../file/area_a.csv", counts_column='net_counts')
df_area_b = pca.fit_transform_csv(input_csv="../file/snip_processed_area_b.csv", output_csv="../file/area_b.csv", counts_column='net_counts')


# # ç»˜åˆ¶æ–¹å·®è´¡çŒ®ç‡å›¾
# pca.plot_variance_ratio()

# # ç»˜åˆ¶ä¸»æˆåˆ†æ•£ç‚¹å›¾ï¼ˆPC1 vs PC2ï¼‰
# pca.plot_scatter(df_area_a, pc_x=1, pc_y=2)

# # ç»˜åˆ¶ç©ºé—´æ•£ç‚¹å›¾ï¼ˆPC1ï¼‰
# pca.plot_spatial_pca(df_area_a, pc=1, method='scatter')

# # ç»˜åˆ¶ç©ºé—´çƒ­åŠ›å›¾ï¼ˆPC1ï¼‰
# pca.plot_spatial_pca(df_area_a, pc=1, method='heatmap', grid_res=200)
```

![image.png](https://img11.360buyimg.com/ddimg/jfs/t1/337796/37/23098/88535/690af732F81de8443/9ba32d410e1ad71d.jpg)