---
layout: post
title: 'LeetCode刷题历程'
subtitle: '菜鸟写BUG'
date: 2020-03-03
categories: 技术
tags: Python 技术 学习
music-id: 1419226279
---

以前都是看别人做题，从来没做过，这次想做一下。

我最开始是学C++的，最后悔的就是数据结构没学好，现在也基本用不到C++了（目前为止），最近正好自学Python，所以答题就用Python了。

所有题目解法不一，思路不一，我放的都是我的第一思路或者学习别人的思路。

看完别人的题解，我基本只会暴力解题，数据结构一片茫然🙃

本博客持续更新，LeetCode刷题全部放在本博客中。


#### 1.

![1](https://cdn.jsdelivr.net/gh/JMbaozi/Blogimg/Pictures/20200303205251.png)

```python
class Solution:
    def game(self, guess: List[int], answer: List[int]) -> int:
        n = 0
        for i in range(len(guess)):
            if guess[i] == answer[i]:
                n+=1
        return n
```

#### 2.

![](https://cdn.jsdelivr.net/gh/JMbaozi/Blogimg/Pictures/20200303211509.png)
```python
class Solution:
    def findNumbers(self, nums: List[int]) -> int:
        n = 0
        for num in nums:
            a = str(num)
            if len(a)%2 == 0:
                n+=1
        return n
    #将数字转成字符，然后看长度是否是偶数。。。
    #这思路，我傻了。
```
```python
from math import log10
class Solution:
    def findNumbers(self, nums: List[int]) -> int:
        n = 0
        for num in nums:
            if int(log10(num)+1)%2 == 0:
                n+=1
        return n
    # log10(n)，表示以10为底n的对数
    # log10(10)    1.0
    # log10(100)   2.0
    # log10(9100)  3.9590413923210934
    # 刚好可以用这个求出数字的位数
    #用户as所写
```

#### 3.

![](https://cdn.jsdelivr.net/gh/JMbaozi/Blogimg/Pictures/20200303213205.png)
```python
class Solution:
    def numJewelsInStones(self, J: str, S: str) -> int:
        num = 0
        for j in J:
            for s in S:
                if j==s:
                    num+=1
        return num

```

#### 4.

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

示例 1：

输入: s = "abcdefg", k = 2
输出: "cdefgab"
示例 2：

输入: s = "lrloseumgh", k = 6
输出: "umghlrlose"

```python
class Solution:
    def reverseLeftWords(self, s: str, n: int) -> str:
        r = s[0:n]
        s = s[n:len(s)]
        s = s + r
        return s
        
        #或者直接简单粗暴一句话：
        #return s[n:]+s[:n]
```

#### 5.

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums)):
            for j in range(i+1,len(nums)):
                if nums[i]+nums[j] == target:
                    a = [i,j]
                    return a
        else:
            return 0
```
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hashmap = {}
        for index, num in enumerate(nums):
            another_num = target - num
            if another_num in hashmap:
                return [hashmap[another_num], index]
            hashmap[num] = index
        return None
    #记一位大佬用字典写的方法
```

#### 6.

给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。

换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] < nums[i] 。

以数组形式返回答案。


示例 1：

输入：nums = [8,1,2,2,3]
输出：[4,0,1,1,3]
解释： 
对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 
对于 nums[1]=1 不存在比它小的数字。
对于 nums[2]=2 存在一个比它小的数字：（1）。 
对于 nums[3]=2 存在一个比它小的数字：（1）。 
对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。
示例 2：

输入：nums = [6,5,4,8]
输出：[2,1,0,3]
示例 3：

输入：nums = [7,7,7,7]
输出：[0,0,0,0]
```python
class Solution:
    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:
        answer = [0]*len(nums)
        num = 0
        for i in range(len(nums)):
            for j in range(len(nums)):
                if nums[j]<nums[i]:
                    num+=1
            answer[i] = num
            num = 0
        return answer
```

#### 7.

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

示例 1:

输入: 123
输出: 321
 示例 2:

输入: -123
输出: -321
示例 3:

输入: 120
输出: 21
注意:

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

```python
class Solution:
    def reverse(self, x: int) -> int:
        a = str(x)[::-1]
        if a.endswith('-'):
            a = str('-') + a[:-1]
            return int(a) if int(a)> -2**31 else 0
        return int(a) if int(a)< 2**31-1 else 0     
```

#### 8.

给你一个非负整数 num ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。

示例 1：

输入：num = 14
输出：6
解释：
步骤 1) 14 是偶数，除以 2 得到 7 。
步骤 2） 7 是奇数，减 1 得到 6 。
步骤 3） 6 是偶数，除以 2 得到 3 。
步骤 4） 3 是奇数，减 1 得到 2 。
步骤 5） 2 是偶数，除以 2 得到 1 。
步骤 6） 1 是奇数，减 1 得到 0 。

```python
class Solution:
    def numberOfSteps (self, num: int) -> int:
        step = 0
        if num ==0:
            return 0
        while num!=0:
            if num % 2 == 0:
                num = num/2
                step+=1
            else:
                num-=1
                step+=1    
            if num == 0:
                return step
```

#### 9.

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

示例 1:

输入: 121
输出: true
示例 2:

输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x<0:
            return False
        a = str(x)
        b = a[::-1]
        if a==b:
            return True
        else:
            return False
```

#### 10.

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]，

   3
   / \
  9  20
      /  \
    15   7
返回它的最大深度 3 。

```python
#方法1：递归

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if root == None:
            return 0
        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1

```

```python
#方法2：迭代
"""
我们还可以在栈的帮助下将上面的递归转换为迭代。

我们的想法是使用 DFS 策略访问每个结点，同时在每次访问时更新最大深度。

所以我们从包含根结点且相应深度为 1 的栈开始。然后我们继续迭代：将当前结点弹出栈并推入子结点。每一步都会更新深度。
"""
class Solution:
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """ 
        stack = []                                              # 定义一个空栈，栈中的元素是结点及其对应的深度
        if root:                                                # 如果根结点不为空
            stack.append((root, 1))                             # 则将根节点及其对应深度1组成的元组入栈
        max_depth = 0                                           # 初始化最大深度为零
        while stack:                                            # 当栈非空时
            tree_node, cur_depth = stack.pop()                  # 弹出栈顶结点及其对应的深度
            if tree_node:                                       # 如果该结点不为空
                max_depth = max(max_depth, cur_depth)           # 更新当前最大深度，如果该结点深度更大的话
                stack.append((tree_node.left, cur_depth+1))     # 将该结点的左孩子结点及其对应深度压入栈中
                stack.append((tree_node.right, cur_depth+1))    # 将该结点的右孩子结点及其对应深度压入栈中
        return max_depth                                        # 返回遍历结束后的最大深度
```

#### 11.

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

示例 1:

输入: ["flower","flow","flight"]
输出: "fl"
示例 2:

输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。

```python
"""
大佬：利用python的max()和min()，在Python里字符串是可以比较的，按照ascII值排，举例abb， aba，abac，最大为abb，最小为aba。所以只需要比较最大最小的公共前缀就是整个数组的公共前缀。
利用python的zip函数，把str看成list然后把输入看成二维数组，左对齐纵向压缩，然后把每项利用集合去重，之后遍历list中找到元素长度大于1之前的就是公共前缀
我：暴力解题 + 面向测试编程 = 不通过😭
"""
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        Min = min(strs)
        Max = max(strs)
        for i in range(len(Min)):
            if Min[i]!=Max[i]:
                return(Min[:i])
        #for i,x in enumerate(Min):
        #    if x!= Max[i]:
        #       return Min[:i]
        return Min
    '''
    def longestCommonPrefix(self, strs):
        if not strs: return ""
        ss = list(map(set, zip(*strs)))
        res = ""
        for i, x in enumerate(ss):
            x = list(x)
            if len(x) > 1:
                break
            res = res + x[0]
        return res    
    '''
```
